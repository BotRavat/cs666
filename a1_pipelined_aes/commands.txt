iverilog -o aes_sim \
    src/test_AES128.v \
    src/AESEncrypt.v \
    src/AddRoundKey.v \
    src/KeyExpansion.v \
    src/MixColumns.v \
    src/ShiftRows.v \
    src/SubBytes.v \
    src/SubTable.v




    yosys -s synth_aes.ys


stat -top AESEncrypt128_DUT > ./src/reports/AESEncrypt128_DUT_report.txt



#synth_aes.sh
# Read only RTL modules, exclude testbench
read_verilog ./src/SubTable.v
read_verilog ./src/SubBytes.v
read_verilog ./src/ShiftRows.v
read_verilog ./src/MixColumns.v
read_verilog ./src/AddRoundKey.v
read_verilog ./src/KeyExpansion.v
read_verilog ./src/AESEncrypt.v

# Top module
synth -top AESEncrypt128_DUT

# Write netlist & report
write_verilog ./src/reports/AESEncrypt128_DUT_netlist.v
stat -top AESEncrypt128_DUT > ./src/reports/AESEncrypt128_DUT_report.txt



aes_dut (
  .data   ( {slv_reg3, slv_reg2, slv_reg1, slv_reg0} ),
  .key    ( {slv_reg7, slv_reg6, slv_reg5, slv_reg4} ),
  .clk    (S_AXI_ACLK),
  .reset  (aes_reset),
  .out    (aes_out),
  .done   (aes_done)
);

assign {slv_reg12, slv_reg11, slv_reg10, slv_reg9} = aes_out;
assign slv_reg13[0] = aes_done;



wire[127:0]ct,pt,key;
wire rst,keyrst,keyready,done;


     9'h009   : reg_data_out <= slv_reg9;
	        9'h00A   : reg_data_out <= ct[31:0];
	        9'h00B   : reg_data_out <= ct[63:32];
	        9'h00C   : reg_data_out <= ct[95:64];
	        9'h00D   : reg_data_out <= ct[127:96];
	        9'h00E   : reg_data_out <= {31'd0,keyready};
	        9'h00F   : reg_data_out <= {31'd0,done};




assign pt={slv_reg3,slv_reg2,slv_reg1,slv_reg0};
assign key={slv_reg7,slv_reg6,slv_reg5,slv_reg4};
assign rst=slv_reg9[0];
assign keyrst=slv_reg8[0];

 AESEncrypt128_DUT aes_dut (
  .data   ( pt ),
  .key    ( key ),
  .clk    (S_AXI_ACLK),
  .reset  (rst),
  .out    (ct),
  .done   (done)
);
