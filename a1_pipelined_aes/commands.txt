iverilog -o aes_sim \
    src/test_AES128.v \
    src/AESEncrypt.v \
    src/AddRoundKey.v \
    src/KeyExpansion.v \
    src/MixColumns.v \
    src/ShiftRows.v \
    src/SubBytes.v \
    src/SubTable.v




    yosys -s synth_aes.ys


stat -top AESEncrypt128_DUT > ./src/reports/AESEncrypt128_DUT_report.txt



#synth_aes.sh
# Read only RTL modules, exclude testbench
read_verilog ./src/SubTable.v
read_verilog ./src/SubBytes.v
read_verilog ./src/ShiftRows.v
read_verilog ./src/MixColumns.v
read_verilog ./src/AddRoundKey.v
read_verilog ./src/KeyExpansion.v
read_verilog ./src/AESEncrypt.v

# Top module
synth -top AESEncrypt128_DUT

# Write netlist & report
write_verilog ./src/reports/AESEncrypt128_DUT_netlist.v
stat -top AESEncrypt128_DUT > ./src/reports/AESEncrypt128_DUT_report.txt



aes_dut (
  .data   ( {slv_reg3, slv_reg2, slv_reg1, slv_reg0} ),
  .key    ( {slv_reg7, slv_reg6, slv_reg5, slv_reg4} ),
  .clk    (S_AXI_ACLK),
  .reset  (aes_reset),
  .out    (aes_out),
  .done   (aes_done)
);

assign {slv_reg12, slv_reg11, slv_reg10, slv_reg9} = aes_out;
assign slv_reg13[0] = aes_done;



wire[127:0]ct,pt,key;
wire rst,keyrst,keyready,done;


     9'h009   : reg_data_out <= slv_reg9;
	        9'h00A   : reg_data_out <= ct[31:0];
	        9'h00B   : reg_data_out <= ct[63:32];
	        9'h00C   : reg_data_out <= ct[95:64];
	        9'h00D   : reg_data_out <= ct[127:96];
	        9'h00E   : reg_data_out <= {31'd0,keyready};
	        9'h00F   : reg_data_out <= {31'd0,done};




assign pt={slv_reg3,slv_reg2,slv_reg1,slv_reg0};
assign key={slv_reg7,slv_reg6,slv_reg5,slv_reg4};
assign rst=slv_reg9[0];
assign keyrst=slv_reg8[0];

 AESEncrypt128_DUT aes_dut (
  .data   ( pt ),
  .key    ( key ),
  .clk    (S_AXI_ACLK),
  .reset  (rst),
  .out    (ct),
  .done   (done)
);







/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xbasic_types.h"
#include "xparameters.h"
#include "xil_io.h"
#include "sleep.h"

Xuint32 *baseaddr = (Xuint32 *)0x43C00000;

int main()
{
    init_platform();

    int slv_reg0, slv_reg1, slv_reg2, slv_reg3, slv_reg4;
    int slv_reg5, slv_reg6, slv_reg7, slv_reg8, slv_reg9;
    int ctext_0, ctext_1, ctext_2, ctext_3, keydone, done;


    slv_reg0 = 0; slv_reg1 = 0; slv_reg2 = 0; slv_reg3 = 0; // plaintext
    slv_reg4 = 0; slv_reg5 = 0; slv_reg6 = 0; slv_reg7 = 0; // key
    slv_reg9 = 1; // rst

    print("hello\n\r");


    Xil_Out32((baseaddr + 4), slv_reg4);
    Xil_Out32((baseaddr + 5), slv_reg5);
    Xil_Out32((baseaddr + 6), slv_reg6);
    Xil_Out32((baseaddr + 7), slv_reg7);
    Xil_Out32((baseaddr + 8), slv_reg8);
    slv_reg8 = 0;
    Xil_Out32((baseaddr + 8), slv_reg8);


    // Write plaintext registers
    Xil_Out32((baseaddr + 0), slv_reg0);
    Xil_Out32((baseaddr + 1), slv_reg1);
    Xil_Out32((baseaddr + 2), slv_reg2);
    Xil_Out32((baseaddr + 3), slv_reg3);
    Xil_Out32((baseaddr + 9), slv_reg9);
    slv_reg9 = 0;
    Xil_Out32((baseaddr + 9), slv_reg9);

    // Wait for encryption done
    while (1)
    {
        done = Xil_In32(baseaddr + 15);
        if (done == 1)
            break;
    }

    // Read ciphertext
    ctext_0 = Xil_In32((baseaddr + 10));
    ctext_1 = Xil_In32((baseaddr + 11));
    ctext_2 = Xil_In32((baseaddr + 12));
    ctext_3 = Xil_In32((baseaddr + 13));

    xil_printf("cipher_32 = %0x\n\r", ctext_0);
    xil_printf("cipher_64 = %0x\n\r", ctext_1);
    xil_printf("cipher_96 = %0x\n\r", ctext_2);
    xil_printf("cipher_128 = %0x\n\r", ctext_3);

    cleanup_platform();
    return 0;
}

